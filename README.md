# phonolex
__Jared Neumann__ <br>
__janeuman@iu.edu__

### Installation
Currently, phonolex is in version 0.0.1-beta. Install via pip:

```
pip install phonolex
```

There are no dependencies outside of the standard Python 3 libraries.

### Description
PhonoLex is an application (in progress) that allows users to write phonological queries that return lists of words satisfying that phonology. Word-level features such as character and phoneme length, number of syllables, the presence of diphthongs, and the frequency of the potential matches, can be combined with phoneme-level features to generate those lists. Phoneme-level features include all manners of articulation, and any number of these features can be combined in a particular order to create patterns. Three options for the mode of matching are available: users can find their patterns starting from the beginning of a word (STARTS_WITH), the end of a word (ENDS_WITH), or anywhere (CONTAINS). 
<br><br>
The initial use-case and motivation for this project was generating phonologically precise word-lists for targeted speech-language pathology therapies.

### Data
The data folder includes four files: cmu.json, features.json, commonlemmas.txt, and commonwords.txt. 
#### *cmu.json*
This file contains a json version of the [CMU Pronouncing Dictionary][1]. It includes a dictionary of English vocabulary terms as keys and an ordered list of phonemes with stress indicated. There are approximately 135k words, some of which are represented more than once with alternate proncunciations.
<details>
  <summary>Vocabulary Example</summary>
  
| WORD |  0  |  1  |  2  |  3  |  4  |  5  |
|:-----|:---:|:---:|:---:|:---:|:---:|:---:|
|banana|  B  | AH0 |  N  | AE1 |  N  | AH0 |
</details>

#### *features.json*
This file maps the ARPAbet symbols for phonemes used in the CMU Pronouncing Dictionary to their corresponding phonological features. These features were derived from the definitions of those symbols. Several features are described, for example:
<details>
  <summary>Feature Example</summary>
  
|    FEATURE   | 'IH' |
|:-------------|-----:|
|TYPE          | V    |
|HEIGHT        | 0.2  |
|DEPTH         | 0.75 |
|ROUNDED       | 0    |
|RHOTIC        | 1    |
|STOP          | None |
|VOICE         | None |
|BILABIAL      | None |
|AFFRICATE     | None |
|ALVEOPALATAL  | None |
|ALVEOLAR      | None |
|FRICATIVE     | None |
|DENTAL        | None |
|LABIODENTAL   | None |
|VELAR         | None |
|LATERAL       | 0    |
|POSTALVEOLAR  | None |
|NASAL         | None |
|LABIOVELAR    | None |
|PALATAL       | None |
|GLIDE         | None |
|GLOTTAL       | None |
</details>

The values may have the following data types: string (for TYPE, i.e., vowel or consonant), float (for all numerical values, even those that are binary), None (for the cases in which a feature is not applicable/possible), and list (for ranges of values as in the case of diphthongs or search queries). Numerical values were derived in two ways: binary values come from the simple presence or absence of the feature, e.g., RHOTIC; other values come from the relative distance of a feature on a continuum. Continuous features are typically described as discrete values that divide a continuum. In the case of HEIGHT, this can be anywhere from 3 to 7 values. Here, 6 values are possible (0.0, 0.2, 0.4, 0.6, 0.8, 1.0).

#### *commonwords.txt*
This file contains 5027 of the most common words in English derived from the [Corpus of Contemporary American English (COCA)][2] 2020 data. The original lists were obtained from www.wordfrequency.info. This particular list contains words and their various forms that also made the top 5027. Duplicates were removed and a new file was generated by cross-referencing the CMU vocabulary (so phonetic descriptions could be obtained). Specifying this file allows the user to avoid obscure results, although there is a smaller *unique* vocabulary than in the next file.

#### *commonlemmas.txt*
This file contains 4369 of the most common lemmas in English derived from the same corpus. Lemmas are the so-called 'dictionary' form of the word, so the list contains a richer unique vocabulary, albeit fewer words altogether. Again, duplicates were removed and the included list has been cross-referenced with the CMU vocabulary.

### Functionality
Currently, there is only the core Phonology class. If you have data in the same format as the available data, an instance can be created that uses it. Otherwise, the defaults will be used. The only dependencies are json for reading the files and pandas for constructing and displaying the description table (not used in the core functionality, but will become important for the GUI).

#### Getting information about particular words
First, initialize the Phonology class:

```
from phonolex.phonology import *

ph = Phonology()
```

If you would like to know the available phonological data about a particular word, you can access those functions directly. All that data is included in the describe(word) function, e.g.,

```
ph.describe('banana')
```

gives the following output (in dictionary format, translated here for readability):
<details>
  <summary>Table 1: Word-Level Features</summary>
  
  |            |         |
  |:-----------|--------:|
  | word       | banana  |
  | is_word    | True    |
  | syllables  | 3       |
  | diphthongs | []      |
  | characters | 6       |
  | phonemes   | 6       |
  
</details>
<details>
  <summary>Table 2: Phoneme-Level Features</summary>
  
|             |   B  | AH0  |  N   | AE1  |  N   | AH0  |
|:------------|:----:|:----:|:----:|:----:|:----:|:----:|
|TYPE         |   C  |  V   | C    | V    | C    | V    |
|HEIGHT       | NaN  |0.6   | NaN  | 0.8  | NaN  | 0.6  |
|DEPTH        | NaN  |  0   | NaN  |  1   | NaN  |  0   |
|ROUNDED      | NaN  |  0   | NaN  |  0   | NaN  |  0   |
|RHOTIC       |   0  |  0   | 0    |  0   | 0    | 0    |
|STOP         |   1  |NaN   | 0    | NaN  |  0   | NaN  |
|VOICE        |   1  |NaN   | 0    | NaN  |  0   | NaN  |
|BILABIAL     |   1  |NaN   | 0    | NaN  |  0   | NaN  |
|AFFRICATE    |   0  |NaN   | 0    | NaN  |  0   | NaN  |
|ALVEOPALATAL |   0  |NaN   | 0    | NaN  |  0   | NaN  |
|ALVEOLAR     |   0  |NaN   | 1    | NaN  |  1   | NaN  |
|FRICATIVE    |   0  |NaN   | 0    | NaN  |  0   | NaN  |
|DENTAL       |   0  |NaN   | 0    | NaN  |  0   | NaN  |
|LABIODENTAL  |   0  |NaN   | 0    | NaN  |  0   | NaN  |
|VELAR        |   0  |NaN   | 0    | NaN  |  0   | NaN  |
|LATERAL      |   0  |  0   | 0    | 0    | 0    | 0    |
|POSTALVEOLAR |   0  |NaN   | 0    | NaN  |  0   | NaN  |
|NASAL        |   0  |NaN   | 1    | NaN  |  1   | NaN  |
|LABIOVELAR   |   0  |NaN   | 0    | NaN  |  0   | NaN  |
|PALATAL      |   0  |NaN   | 0    | NaN  |  0   | NaN  |
|GLIDE        |   0  |NaN   | 0    | NaN  |  0   | NaN  |
|GLOTTAL      |   0  |NaN   | 0    | NaN  |  0   | NaN  |
  
</details>

One limitation of this function currently is that it only returns the first match. So, if there are alternate pronunciations, only the primary pronunciation is returned. However, alternate pronunciations can be looked up directly by adding (2) or some other (higher) number in parentheses to the search term.

#### Query formats

To query the data for particular patterns, use the match() function. 
```
ph.match(word_features = [], phone_features = [], mode = 'CONTAINS', frequency = 'ALL')
```

###### word_features

Word-level features are specified using a dictionary of features. The possible features are 'SYLLABLES', 'CHARACTERS', 'PHONEMES', 'CONTAINS_DIPHTHONG'. The first three require integer values, while the last requires a boolean. Note: 'CONTAINS_DIPHTHONG' should only be used if it matters whether the results contain diphthongs. False will result in no matches with diphthongs and True will result in all matches with diphthongs.

<details>
  <summary>word_features Example</summary>
  
  ```
  word_features = {'SYLLABLES': 3, 'CHARACTERS': [5, 10], 'CONTAINS_DIPHTHONG': False}
  ```
  
</details>

Also notice that the integers values could also be lists of two integers values. This will define a range with a min and max. That means this query will return words with anywhere from 5 to 10 characters, so long as the other criteria are satisfied.

###### phone_features

Phoneme-level features are specified using a *list* of dictionaries containing features. The possible features are all those included in the above table containing the manners of articulation with the indicated data types. The list is positional, so the order matters. The pattern will be matched in the order it occurs in the word.

<details>
  <summary>phone_features Example</summary>
  
  ```
  phone_features = [
  {'TYPE': 'C', 'STOP': 1.0}, 
  {'TYPE': 'V', 'HEIGHT': [0.6, 1.0]}
  ]
  ```
  
</details>

This pattern will match any word containing a stop-consonant (e.g., 'D') immediately followed by any mid-high vowel (e.g., 'AH').

###### mode

The mode argument allows the user to indicate whether a pattern should be matched anywhere (default), from the beginning of the word, or at the end of the word (the class allows for the creation of an interesting rhyme or slant-rhyme generator!). Options are 'CONTAINS', 'STARTS_WITH', and 'ENDS_WITH'. They each use the same comparison function. 'CONTAINS' is obviously the most computationally intensive. 'ENDS_WITH' simply reverses both the pattern and prospective match and works the same way as 'STARTS_WITH'. 'CONTAINS' works the same way as 'STARTS_WITH', but contains trying to match starting at each successive index of the word's phonemes until it finds a match or the length of the pattern is greater than the remainder of the phonemes.

###### frequency

The frequency argument allows the user to indicate whether the entire CMU Pronouncing Dictionary should be searched or one of the smaller wordlists. Options are 'ALL' (CMU), 'COMMON_WORDS' (common words with word forms), and 'COMMON_LEMMAS' (common words in the base form). The benefits of each are given above.

###### Examples

The following are some example searches with results.
<details>
  <summary>Query Example 1</summary>
  
  ```
  word_features = {'SYLLABLES': 3, 'CHARACTERS': [5, 10], 'CONTAINS_DIPHTHONG': False}
  
  phone_features = [
  {'TYPE': 'C', 'STOP': 1.0}, 
  {'TYPE': 'V', 'HEIGHT': [0.6, 1.0]}
  ]
  
  ph.match(word_features, phone_features, mode = 'STARTS_WITH', frequency = 'COMMON_WORDS')
  ```
  
</details>

This query returns a list containing 114 items:
['together', 'company', 'possible', 'policy', 'personal', 'companies', 'position', 'continue', 'director', 'potential', ...]

The same query using the CMU vocabulary returns 4741 results. Using the common lemmas wordlist, there are 107 results.

We can also use empty lists to match anything in position.

<details>
  <summary>Query Example 2</summary>
  
  ```
  word_features = {'SYLLABLES': [2,3], 'CHARACTERS': [4, 8], 'PHONEMES': [3, 6] 'CONTAINS_DIPHTHONG': True}
  
  phone_features = [
  {'TYPE': 'C', 'STOP': 1.0},
  {'TYPE': 'V', 'HEIGHT': 0.4},
  {'TYPE': 'C', 'VELAR': 0.0},
  {}
  ]
  
  ph.match(word_features, phone_features, mode = 'CONTAINS', frequency = 'ALL')
  ```
</details>

This query returns a list containing 30 items:
['baudoin', 'beaupre', 'boelkow', 'bolkow', 'bolshoi', 'bovine', 'bowdoin', 'bowline', 'co-wife', 'cobain', 'cobaine', 'coday', 
'cofide', 'colao', 'dochow', 'dolce', 'domain', 'domaine', 'donate', 'godown', 'kobe', "kobe's", 'komine', 'podell', 'pohnpei', ...]

The same query using the common words list returns 1 result ('domain'). Using the common lemmas list, there are 2 results ('domain', 'donate').

Also, note that neither word_features nor phone_features are *required* arguments. Either one can be left out for matches that only pertain to the desired level of the criteria (word or phoneme).

[1]: http://www.speech.cs.cmu.edu/cgi-bin/cmudict
[2]: https://www.english-corpora.org/coca/
